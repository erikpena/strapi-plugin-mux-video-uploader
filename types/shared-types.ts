import { InputSettings } from '@mux/mux-node';
import { z } from 'zod';
import LanguagesList, { LanguageCode } from 'iso-639-1';
import pluginId from '../admin/src/pluginId';
import { Entity } from '@strapi/strapi';

export const SUPPORTED_MUX_LANGUAGES = [
  { label: 'English', code: 'en', state: 'Stable' },
  { label: 'Spanish', code: 'es', state: 'Stable' },
  { label: 'Italian', code: 'it', state: 'Stable' },
  { label: 'Portuguese', code: 'pt', state: 'Stable' },
  { label: 'German', code: 'de', state: 'Stable' },
  { label: 'French', code: 'fr', state: 'Stable' },
  { label: 'Polish', code: 'pl', state: 'Beta' },
  { label: 'Russian', code: 'ru', state: 'Beta' },
  { label: 'Dutch', code: 'nl', state: 'Beta' },
  { label: 'Catalan', code: 'ca', state: 'Beta' },
  { label: 'Turkish', code: 'tr', state: 'Beta' },
  { label: 'Swedish', code: 'sv', state: 'Beta' },
  { label: 'Ukrainian', code: 'uk', state: 'Beta' },
  { label: 'Norwegian', code: 'no', state: 'Beta' },
  { label: 'Finnish', code: 'fi', state: 'Beta' },
  { label: 'Slovak', code: 'sk', state: 'Beta' },
  { label: 'Greek', code: 'el', state: 'Beta' },
  { label: 'Czech', code: 'cs', state: 'Beta' },
  { label: 'Croatian', code: 'hr', state: 'Beta' },
  { label: 'Danish', code: 'da', state: 'Beta' },
  { label: 'Romanian', code: 'ro', state: 'Beta' },
  { label: 'Bulgarian', code: 'bg', state: 'Beta' },
] as const;

const SUPPORTED_MUX_LANGUAGES_VALUES = SUPPORTED_MUX_LANGUAGES.map((l) => l.code);

export type SupportedMuxLanguage = (typeof SUPPORTED_MUX_LANGUAGES_VALUES)[number];

/** .srt or .vtt file uploaded as subtitle/caption for a video */
export const TextTrackFile = z.object({
  contents: z.string(),
  type: z.string(),
  name: z.string(),
  size: z.number(),
});

/** Subtitles and captions uploaded by the user */
export const CustomTextTrack = z.object({
  file: TextTrackFile,
  name: z.string(),
  language_code: z.enum(LanguagesList.getAllCodes() as [LanguageCode, ...LanguageCode[]]),
  closed_captions: z.boolean().default(false),
});

export type ParsedCustomTextTrack = z.infer<typeof CustomTextTrack>;

export type StoredTextTrack = ParsedCustomTextTrack & { id: Entity.ID };

export const UploadConfig = z
  .object({
    /**
     * Enable static renditions by setting this to 'standard'. Can be overwritten on a per-asset basis.
     * @see {@link https://docs.mux.com/guides/video/enable-static-mp4-renditions#why-enable-mp4-support}
     * @defaultValue 'none'
     */
    mp4_support: z.enum(['none', 'standard']).default('none'),

    /**
     * Max resolution tier can be used to control the maximum resolution_tier your asset is encoded, stored, and streamed at.
     * @see {@link https://docs.mux.com/guides/stream-videos-in-4k}
     * @defaultValue '1080p'
     */
    max_resolution_tier: z.enum(['2160p', '1440p', '1080p']).default('1080p'),

    /**
     * The encoding tier informs the cost, quality, and available platform features for the asset.
     * @see {@link https://docs.mux.com/guides/use-encoding-tiers}
     * @defaultValue 'smart'
     */
    encoding_tier: z.enum(['baseline', 'smart']).default('smart'),

    /**
     * Whether or not to use signed URLs, making the asset private
     * @see {@link https://docs.mux.com/guides/use-encoding-tiers}
     * @defaultValue 'false'
     */
    signed: z
      .enum(['true', 'false'])
      .or(z.boolean())
      .default(false)
      .transform((v) => v === 'true' || v === true),

    text_tracks_type: z.enum(['none', 'autogenerated', 'uploaded']).default('none'),
    autogenerated_captions_languages: z
      .array(
        z.object({
          code: z.enum(SUPPORTED_MUX_LANGUAGES_VALUES as [SupportedMuxLanguage, ...SupportedMuxLanguage[]]),
          isSourceLanguage: z.boolean().default(false),
        })
      )
      .optional(),

    custom_text_tracks: z.array(CustomTextTrack).optional(),

    upload_type: z.enum(['file', 'url']).default('file'),
  })
  .transform((v) => {
    if (v.encoding_tier === 'baseline') {
      return {
        ...v,
        max_resolution_tier: '1080p',
        mp4_support: 'none',
      } as typeof v;
    }

    return v;
  });

export type RequestedUploadConfig = z.input<typeof UploadConfig>;
export type ParsedUploadConfig = z.infer<typeof UploadConfig>;

export function uploadConfigToNewAssetInput(
  config: ParsedUploadConfig,
  storedTextTracks: StoredTextTrack[] = [],
  url?: string
): InputSettings[] | undefined {
  if (config.text_tracks_type === 'autogenerated' && config.autogenerated_captions_languages) {
    return [
      {
        // If a remote upload (via URL), join `generated_subtitles` to tell Mux to generated from this URL
        url,
        generated_subtitles: config.autogenerated_captions_languages.map((language) => {
          const label = SUPPORTED_MUX_LANGUAGES.find((l) => l.code === language.code)?.label || language.code;
          return {
            language_code: language.code,
            name: language.isSourceLanguage ? `${label} (CC)` : label,
          };
        }),
      } as InputSettings,
    ];
  }

  if (config.text_tracks_type === 'uploaded' && storedTextTracks.length > 0) {
    return storedTextTracks.map((track) => ({
      type: 'text',
      text_type: 'subtitles',
      closed_captions: track.closed_captions,
      language_code: track.language_code,
      name: track.closed_captions ? `${track.name} (CC)` : track.name,
      url: getTextTrackUrl(track.id),
    }));
  }

  if (url) {
    return [{ url }];
  }

  return undefined;
}

const BASE_URL = (strapi as any).backendURL;

function getTextTrackUrl(id: StoredTextTrack['id']) {
  return `${BASE_URL}/${pluginId}/mux-text-tracks/${id}`;
}
